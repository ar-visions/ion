struct vary {
    @builtin(position) gl_Position : vec4f,
    @location(0)       uv0         : vec2f
};

struct light {
    pos   : vec3f,
    color : vec4f
};

struct ustate {
    model  : mat4x4f,
    view   : mat4x4f,
    proj   : mat4x4f,
    eye    : vec4f,
    lights : array<light, 4>
};

@group(0) @binding(0)  var<uniform> u     : ustate;
@group(0) @binding(1)  var<storage> bones : array<mat4x4f>;
@group(0) @binding(2)  var color          : texture_2d<f32>;
@group(0) @binding(3)  var color_sa       : sampler;
@group(0) @binding(4)  var normal         : texture_2d<f32>;
@group(0) @binding(5)  var normal_sa      : sampler;
@group(0) @binding(6)  var material       : texture_2d<f32>;
@group(0) @binding(7)  var material_sa    : sampler;
@group(0) @binding(8)  var reflect        : texture_2d<f32>;
@group(0) @binding(9)  var reflect_sa     : sampler;
@group(0) @binding(10) var env            : texture_2d<f32>;
@group(0) @binding(11) var env_sa         : sampler;

struct attribs {
    @location(0) pos      : vec3f,
    @location(1) normal   : vec3f,
    @location(2) uv0      : vec2f,
    @location(3) uv1      : vec2f,
    @location(4) tangent  : vec4f,
    @location(5) joints0  : vec4<u32>,
    @location(6) joints1  : vec4<u32>,
    @location(7) weights0 : vec4<f32>,
    @location(8) weights1 : vec4<f32>
};

@vertex
fn vertex_main(a : attribs) -> vary {
    var v : vary;
    let pos4      = vec4f(a.pos, 1.0f);
    var skin_pos : vec4f = vec4f(0.0f);
    for (var i:u32 = 0u; i < 4u; i = i + 1u) {
        skin_pos = skin_pos + bones[a.joints0[i]] * a.weights0[i] * pos4;
    }
    let world_pos = u.view * u.model * skin_pos;
    let  clip_pos = u.proj * world_pos;
    v.gl_Position = clip_pos;
    v.uv0         = a.uv0;
    return v;
}

@fragment
fn fragment_main(v : vary) -> @location(0) vec4f {
    let color = textureSample(color, color_sa, v.uv0);
    return color;
}
